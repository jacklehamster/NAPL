function L(G){let{userId:q,worldId:V,room:A,host:B,autoRejoin:K=!0,logLine:Y}=G,_=!1,$=0,J,T,h=!0,k=new Map,b=`wss://${B}/room/${V}/${A}?userId=${encodeURIComponent(q)}`,W=[],M=0;function F(D,H,O){if(!J)return Y?.("\uD83D\uDC64 ➡️ ❌","no ws available"),!1;if(_||J.readyState!==WebSocket.OPEN)return Y?.("\uD83D\uDC64 ➡️ ❌","Not in opened state: "+J.readyState),!1;let z={type:D,to:H,payload:O};return W.push(z),Y?.("\uD83D\uDC64 ➡️ \uD83D\uDDA5️",z),clearTimeout(M),M=setTimeout(()=>{J.send(JSON.stringify(W)),W.length=0}),!0}function P(){if(_)return;J=new WebSocket(b),J.onopen=()=>{if(h)G.onOpen?.(),h=!1;$=0},J.onmessage=(D)=>{try{let H=JSON.parse(D.data);(Array.isArray(H)?H:[H]).forEach((z)=>{if(Y?.("\uD83D\uDDA5️ ➡️ \uD83D\uDC64",z),z.type==="peer-joined"||z.type==="peer-left")C(z.users);else if(z.type==="ice-server")G.onIceUrl?.(z.url,z.expiration);else if(z.userId)G.onMessage(z.type,z.payload,{userId:z.userId,receive:(E,X)=>F(E,z.userId,X)})})}catch{Y?.("⚠️ ERROR",{error:"invalid-json"})}},J.onclose=(D)=>{let O=[1001,1006,1011,1012,1013].includes(D.code);if(K&&!_&&O){let z=Math.min(Math.pow(2,$)*1000,30000),E=Math.random()*1000,X=z+E;Y?.("\uD83D\uDD04 RECONNECTING",{attempt:$+1,delayMs:Math.round(X)}),$++,T=setTimeout(P,X)}else G.onClose?.({code:D.code,reason:D.reason,wasClean:D.wasClean})},J.onerror=(D)=>{console.error("WS Error",D),G.onError?.()}}function C(D){let H=[],O=[],z=new Set;D.forEach(({userId:E})=>{if(E===q)return;if(!k.has(E)){let X={userId:E,receive:(x,S)=>F(x,E,S)};k.set(E,X),H.push(X)}z.add(E)});for(let E of k.keys())if(!z.has(E))k.delete(E),O.push({userId:E});if(H.length)G.onPeerJoined(H);if(O.length)G.onPeerLeft(O)}return P(),{sendToServer(D,H){F(D,"server",H)},exitRoom:()=>{_=!0,clearTimeout(T),J.close()}}}var N=null,R,Z=new Map;function Q(G){self.postMessage(G)}self.addEventListener("message",(G)=>{let q=G.data;if(console.debug("[signal-room.worker] received command",q),q.cmd==="enter"){N?.(),N=null,Z.clear();let V=L({userId:q.userId,worldId:q.worldId,room:q.room,host:q.host,autoRejoin:q.autoRejoin,onOpen:()=>Q({kind:"open"}),onClose:({code:A,reason:B,wasClean:K})=>Q({kind:"close",ev:{code:A,reason:B,wasClean:K}}),onError:()=>Q({kind:"error"}),logLine:(A,B)=>{console.debug(`[signal-room.worker] ${A}`,B),Q({kind:"log",direction:A,obj:B})},onPeerJoined:(A)=>{A.forEach(({userId:B,receive:K})=>Z.set(`${q.host}/${q.room}/${B}`,K)),Q({kind:"peer-joined",users:A.map(({userId:B})=>({userId:B}))})},onPeerLeft:(A)=>{A.forEach(({userId:B})=>Z.delete(`${q.host}/${q.room}/${B}`)),Q({kind:"peer-left",users:A})},onIceUrl(A,B){Q({kind:"ice-server",url:A,expiration:B})},onMessage:(A,B,K)=>{Z.set(`${q.host}/${q.room}/${K.userId}`,K.receive),Q({kind:"message",type:A,payload:B,fromUserId:K.userId})}});N=V.exitRoom,R=V.sendToServer;return}if(q.cmd==="send"){if(q.toUserId==="server")R?.(q.type,q.payload);else if(q.toUserId){let V=Z.get(`${q.host}/${q.room}/${q.toUserId}`);if(V)V(q.type,q.payload)}return}if(q.cmd==="exit"){N?.(),self.close();return}});

//# debugId=2CF35B1C9F28B90764756E2164756E21
//# sourceMappingURL=signal-room.worker.js.map
