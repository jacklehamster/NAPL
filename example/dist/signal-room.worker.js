function h(E){let{userId:q,appId:T,room:A,host:B,autoRejoin:G=!0,logLine:Y}=E,Z=!1,_=0,H,M,N=!0,$=new Map,L=`wss://${B}/room/${T}/${A}?userId=${encodeURIComponent(q)}`;function W(D,z,J){if(!H)return!1;if(Z||H.readyState!==WebSocket.OPEN)return!1;let K={type:D,to:z,payload:J};return H.send(JSON.stringify(K)),Y?.("\uD83D\uDC64 ➡️ \uD83D\uDDA5️",K),!0}function F(){if(Z)return;H=new WebSocket(L),H.onopen=()=>{if(N)E.onOpen?.(),N=!1;_=0},H.onmessage=(D)=>{try{let z=JSON.parse(D.data);if(Y?.("\uD83D\uDDA5️ ➡️ \uD83D\uDC64",z),z.type==="peer-joined"||z.type==="peer-left")P(z.users);else if(z.userId)E.onMessage(z.type,z.payload,{userId:z.userId,receive:(J,K)=>W(J,z.userId,K)})}catch{Y?.("⚠️ ERROR",{error:"invalid-json"})}},H.onclose=(D)=>{let J=[1001,1006,1011,1012,1013].includes(D.code);if(G&&!Z&&J){let K=Math.min(Math.pow(2,_)*1000,30000),O=Math.random()*1000,V=K+O;Y?.("\uD83D\uDD04 RECONNECTING",{attempt:_+1,delayMs:Math.round(V)}),_++,M=setTimeout(F,V)}else E.onClose?.({code:D.code,reason:D.reason,wasClean:D.wasClean})},H.onerror=(D)=>{console.error("WS Error",D),E.onError?.()}}function P(D){let z=[],J=[],K=new Set;D.forEach(({userId:O})=>{if(O===q)return;if(!$.has(q)){let V={userId:O,receive:(R,b)=>W(R,O,b)};$.set(q,V),z.push(V)}K.add(q)});for(let O of $.keys())if(!K.has(O))$.delete(O),J.push({userId:O});if(z.length)E.onPeerJoined(z);if(J.length)E.onPeerLeft(J)}return F(),{exitRoom:()=>{Z=!0,clearTimeout(M),H.close()}}}var k=null,X=new Map;function Q(E){self.postMessage(E)}self.addEventListener("message",(E)=>{let q=E.data;if(console.debug("[signal-room.worker] received command",q),q.cmd==="enter"){k?.(),k=null,X.clear(),k=h({userId:q.userId,appId:q.appId,room:q.room,host:q.host,autoRejoin:q.autoRejoin,onOpen:()=>Q({kind:"open"}),onClose:({code:A,reason:B,wasClean:G})=>Q({kind:"close",ev:{code:A,reason:B,wasClean:G}}),onError:()=>Q({kind:"error"}),logLine:(A,B)=>{console.debug(`[signal-room.worker] ${A}`,B),Q({kind:"log",direction:A,obj:B})},onPeerJoined:(A)=>{A.forEach(({userId:B,receive:G})=>X.set(`${q.host}/${q.room}/${B}`,G)),Q({kind:"peer-joined",users:A.map(({userId:B})=>({userId:B}))})},onPeerLeft:(A)=>{A.forEach(({userId:B})=>X.delete(`${q.host}/${q.room}/${B}`)),Q({kind:"peer-left",users:A})},onMessage:(A,B,G)=>{X.set(`${q.host}/${q.room}/${G.userId}`,G.receive),Q({kind:"message",type:A,payload:B,fromUserId:G.userId})}}).exitRoom;return}if(q.cmd==="send"){let T=X.get(`${q.host}/${q.room}/${q.toUserId}`);if(T)T(q.type,q.payload);return}if(q.cmd==="exit"){k?.(),self.close();return}});

//# debugId=A512E95164BF8BA264756E2164756E21
//# sourceMappingURL=signal-room.worker.js.map
