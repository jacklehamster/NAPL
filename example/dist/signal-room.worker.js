function L(E){let{userId:z,appId:V,room:A,host:B,autoRejoin:D=!0,logLine:Y}=E,Z=!1,_=0,O,M,N=!0,$=new Map,P=`wss://${B}/room/${V}/${A}?userId=${encodeURIComponent(z)}`;function W(){if(Z)return;O=new WebSocket(P),O.onopen=()=>{if(N)E.onOpen?.(),N=!1;_=0},O.onmessage=(G)=>{try{let q=JSON.parse(G.data);if(Y?.("\uD83D\uDDA5️ ➡️ \uD83D\uDC64",q),q.type==="peer-joined"||q.type==="peer-left")R(q.users);else if(q.peerId&&q.userId)E.onMessage(q.type,q.payload,{userId:q.userId,peerId:q.peerId,receive:(J,K)=>F(J,q.peerId,K)})}catch{Y?.("⚠️ ERROR",{error:"invalid-json"})}},O.onclose=(G)=>{let J=[1001,1006,1011,1012,1013].includes(G.code);if(D&&!Z&&J){let K=Math.min(Math.pow(2,_)*1000,30000),Q=Math.random()*1000,H=K+Q;Y?.("\uD83D\uDD04 RECONNECTING",{attempt:_+1,delayMs:Math.round(H)}),_++,M=setTimeout(W,H)}else E.onClose?.({code:G.code,reason:G.reason,wasClean:G.wasClean})},O.onerror=()=>E.onError?.()}function F(G,q,J){if(Z||O.readyState!==WebSocket.OPEN)return!1;let K={type:G,to:q,payload:J};return O.send(JSON.stringify(K)),Y?.("\uD83D\uDC64 ➡️ \uD83D\uDDA5️",K),!0}function R(G){let q=[],J=[],K=new Set;G.forEach(({userId:Q,peerId:H})=>{if(Q===z)return;if(!$.has(H)){let h={userId:Q,peerId:H,receive:(U,b)=>F(U,H,b)};$.set(H,h),q.push(h)}K.add(H)});for(let[Q,H]of $.entries())if(!K.has(Q))$.delete(Q),J.push({peerId:Q,userId:H.userId});if(q.length)E.onPeerJoined(q);if(J.length)E.onPeerLeft(J)}return W(),{exitRoom:()=>{Z=!0,clearTimeout(M),O.close()}}}var k=null,X=new Map;function T(E){self.postMessage(E)}self.addEventListener("message",(E)=>{let z=E.data;if(console.debug("[signal-room.worker] received command",z),z.cmd==="enter"){k?.(),k=null,X.clear(),k=L({userId:z.userId,appId:z.appId,room:z.room,host:z.host,autoRejoin:z.autoRejoin,onOpen:()=>T({kind:"open"}),onClose:({code:A,reason:B,wasClean:D})=>T({kind:"close",ev:{code:A,reason:B,wasClean:D}}),onError:()=>T({kind:"error"}),logLine:(A,B)=>{console.debug(`[signal-room.worker] ${A}`,B),T({kind:"log",direction:A,obj:B})},onPeerJoined:(A)=>{A.forEach(({peerId:B,receive:D})=>X.set(B,D)),T({kind:"peer-joined",users:A.map(({userId:B,peerId:D})=>({userId:B,peerId:D}))})},onPeerLeft:(A)=>{A.forEach(({peerId:B})=>X.delete(B)),T({kind:"peer-left",users:A})},onMessage:(A,B,D)=>{X.set(D.peerId,D.receive),T({kind:"message",type:A,payload:B,fromUserId:D.userId,fromPeerId:D.peerId})}}).exitRoom;return}if(z.cmd==="send"){let V=X.get(z.toPeerId);if(V)V(z.type,z.payload);return}if(z.cmd==="exit"){k?.(),self.close();return}});

//# debugId=4DD28392E847F61864756E2164756E21
//# sourceMappingURL=signal-room.worker.js.map
