{
  "version": 3,
  "sources": ["../src/browser/impl/signal-room.ts", "../src/browser/signal-room.worker.ts"],
  "sourcesContent": [
    "export interface IPeer<T extends string = string, P = any> {\n  userId: string;\n  receive(type: T, payload: P): boolean;\n}\n\ntype OutMessage = { type: string; to: string; payload: any };\n\n/**\n * enterRoom connects to the signaling room via WebSocket.\n */\nexport function enterRoom<T extends string, P = any>(params: {\n  userId: string;\n  worldId: string;\n  room: string;\n  host: string;\n  onOpen?: () => void;\n  onClose?: (ev: Pick<CloseEvent, \"code\" | \"reason\" | \"wasClean\">) => void;\n  onError?: () => void;\n  logLine?: (direction: string, obj?: any) => void;\n  onPeerJoined(users: IPeer<T, P>[]): void;\n  onPeerLeft(users: { userId: string }[]): void;\n  onIceUrl?(url: string): void;\n  onMessage(type: T, payload: P, from: IPeer<T, P>): void;\n  autoRejoin?: boolean;\n}): {\n  exitRoom: () => void;\n  sendToServer: <P extends any>(type: T, payload?: P) => void;\n} {\n  type Message = {\n    type: \"peer-joined\" | \"peer-left\" | \"ice-server\" | T;\n    userId: string;\n    users: { userId: string }[];\n    payload: P;\n    url: string;\n  };\n\n  const { userId, worldId, room, host, autoRejoin = true, logLine } = params;\n\n  let exited = false;\n  let retryCount = 0;\n  let ws: WebSocket;\n  let timeoutId: ReturnType<typeof setTimeout>;\n  let initialConnection = true;\n\n  const peers = new Map<string, IPeer<T, P>>();\n  const wsUrl = `wss://${host}/room/${worldId}/${room}?userId=${encodeURIComponent(\n    userId,\n  )}`;\n\n  // Helper for sending (uses the current ws instance)\n  const accumulatedMessages: OutMessage[] = [];\n  let timeout: ReturnType<typeof setTimeout> = 0;\n  function send(type: string, to: \"server\" | string, payload?: any) {\n    if (!ws) return false;\n    if (exited || ws.readyState !== WebSocket.OPEN) return false;\n    const obj: OutMessage = { type, to, payload };\n    accumulatedMessages.push(obj);\n    // ws.send(JSON.stringify(obj));\n    logLine?.(\"ðŸ‘¤ âž¡ï¸ ðŸ–¥ï¸\", obj);\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      ws.send(JSON.stringify(accumulatedMessages));\n      accumulatedMessages.length = 0;\n    });\n    return true;\n  }\n\n  function connect() {\n    if (exited) return;\n\n    ws = new WebSocket(wsUrl);\n\n    ws.onopen = () => {\n      if (initialConnection) {\n        params.onOpen?.();\n        initialConnection = false;\n      }\n      retryCount = 0; // Reset backoff on successful connection\n    };\n\n    ws.onmessage = (e: MessageEvent) => {\n      try {\n        const result = JSON.parse(e.data);\n        const msgs: Message[] = Array.isArray(result) ? result : [result];\n        msgs.forEach((msg) => {\n          logLine?.(\"ðŸ–¥ï¸ âž¡ï¸ ðŸ‘¤\", msg);\n          if (msg.type === \"peer-joined\" || msg.type === \"peer-left\") {\n            updatePeers(msg.users);\n          } else if (msg.type === \"ice-server\") {\n            params.onIceUrl?.(msg.url);\n          } else if (msg.userId) {\n            params.onMessage(msg.type, msg.payload, {\n              userId: msg.userId,\n              receive: (type: T, payload: P) => send(type, msg.userId, payload),\n            });\n          }\n        });\n      } catch {\n        logLine?.(\"âš ï¸ ERROR\", { error: \"invalid-json\" });\n      }\n    };\n\n    ws.onclose = (ev: CloseEvent) => {\n      // 1. Check if we should even try to reconnect\n      const recoverableCodes = [1001, 1006, 1011, 1012, 1013];\n      const isRecoverable = recoverableCodes.includes(ev.code);\n\n      if (autoRejoin && !exited && isRecoverable) {\n        // 2. Exponential Backoff: 1s, 2s, 4s, 8s... capped at 30s\n        const backoff = Math.min(Math.pow(2, retryCount) * 1000, 30000);\n        // 3. Add Jitter: +/- 1000ms randomness\n        const jitter = Math.random() * 1000;\n        const delay = backoff + jitter;\n\n        logLine?.(\"ðŸ”„ RECONNECTING\", {\n          attempt: retryCount + 1,\n          delayMs: Math.round(delay),\n        });\n\n        retryCount++;\n        timeoutId = setTimeout(connect, delay);\n      } else {\n        params.onClose?.({\n          code: ev.code,\n          reason: ev.reason,\n          wasClean: ev.wasClean,\n        });\n      }\n    };\n\n    ws.onerror = (ev) => {\n      console.error(\"WS Error\", ev);\n      params.onError?.();\n    };\n  }\n\n  // Helper for peer tracking (logic from your original code)\n  function updatePeers(updatedUsers: { userId: string }[]) {\n    const joined: IPeer<T, P>[] = [];\n    const left: { userId: string }[] = [];\n    const updatedPeerSet = new Set<string>();\n\n    updatedUsers.forEach(({ userId: pUserId }) => {\n      if (pUserId === userId) return;\n      if (!peers.has(userId)) {\n        const newPeer = {\n          userId: pUserId,\n          receive: (t: T, p: P) => send(t, pUserId, p),\n        };\n        peers.set(userId, newPeer);\n        joined.push(newPeer);\n      }\n      updatedPeerSet.add(userId);\n    });\n\n    for (const userId of peers.keys()) {\n      if (!updatedPeerSet.has(userId)) {\n        peers.delete(userId);\n        left.push({ userId });\n      }\n    }\n    //  Notify peer joined first then peer left. (avoid disconnect in case the peer leaving / joining is on the same user).\n    if (joined.length) params.onPeerJoined(joined);\n    if (left.length) params.onPeerLeft(left);\n  }\n\n  // Start initial connection\n  connect();\n\n  return {\n    sendToServer(type, payload) {\n      send(type, \"server\", payload);\n    },\n    exitRoom: () => {\n      exited = true;\n      clearTimeout(timeoutId);\n      ws.close();\n    },\n  };\n}\n",
    "/// <reference lib=\"webworker\" />\n\nimport { enterRoom, type IPeer } from \"./impl/signal-room.js\";\n\nexport type RoomEvent<T extends string = string, P = any> =\n  | { kind: \"open\" }\n  | { kind: \"close\"; ev: Pick<CloseEvent, \"code\" | \"reason\" | \"wasClean\"> }\n  | { kind: \"error\" }\n  | { kind: \"peer-joined\"; users: { userId: string }[] }\n  | { kind: \"peer-left\"; users: { userId: string }[] }\n  | { kind: \"ice-server\"; url: string }\n  | {\n      kind: \"message\";\n      type: T;\n      payload: P;\n      fromUserId: string;\n    }\n  | { kind: \"log\"; direction: string; obj?: any };\n\nexport type WorkerCommand<T extends string = string, P = any> =\n  | {\n      cmd: \"enter\";\n      userId: string;\n      worldId: string;\n      room: string;\n      host: string;\n      autoRejoin: boolean;\n    }\n  | { cmd: \"exit\" }\n  | {\n      cmd: \"send\";\n      host: string;\n      room: string;\n      toUserId?: \"server\" | string;\n      type: T;\n      payload?: P;\n    };\n\nlet exitRoom: (() => void) | null = null;\nlet sendToServer: (type: string, payload?: any) => void;\n\n// Map from userId -> a function to send to that peer (comes from IUser.receive)\nconst peerSend = new Map<string, (type: any, payload: any) => boolean>();\n\nfunction emit<T extends string, P>(ev: RoomEvent<T, P>) {\n  (self as DedicatedWorkerGlobalScope).postMessage(ev);\n}\n\nself.addEventListener(\"message\", (e: MessageEvent<WorkerCommand>) => {\n  const msg = e.data;\n  console.debug(\"[signal-room.worker] received command\", msg);\n\n  if (msg.cmd === \"enter\") {\n    // If re-entering, clean up first\n    exitRoom?.();\n    exitRoom = null;\n    peerSend.clear();\n\n    const result = enterRoom({\n      userId: msg.userId,\n      worldId: msg.worldId,\n      room: msg.room,\n      host: msg.host,\n      autoRejoin: msg.autoRejoin,\n      onOpen: () => emit({ kind: \"open\" }),\n      onClose: ({\n        code,\n        reason,\n        wasClean,\n      }: Pick<CloseEvent, \"code\" | \"reason\" | \"wasClean\">) =>\n        emit({ kind: \"close\", ev: { code, reason, wasClean } }),\n      onError: () => emit({ kind: \"error\" }),\n      logLine: (direction: string, obj?: any) => {\n        console.debug(`[signal-room.worker] ${direction}`, obj);\n        emit({ kind: \"log\", direction, obj });\n      },\n      onPeerJoined: (users: IPeer[]) => {\n        // Save the ability to send to this peer\n        users.forEach(({ userId, receive }) =>\n          peerSend.set(`${msg.host}/${msg.room}/${userId}`, receive),\n        );\n        emit({\n          kind: \"peer-joined\",\n          users: users.map(({ userId }) => ({ userId })),\n        });\n      },\n      onPeerLeft: (users: { userId: string }[]) => {\n        users.forEach(({ userId }) =>\n          peerSend.delete(`${msg.host}/${msg.room}/${userId}`),\n        );\n        emit({ kind: \"peer-left\", users });\n      },\n      onIceUrl(url: string) {\n        emit({ kind: \"ice-server\", url });\n      },\n      onMessage: (type: any, payload: any, from: IPeer) => {\n        // We can also learn peerSend via onMessage in case join events vary\n        peerSend.set(`${msg.host}/${msg.room}/${from.userId}`, from.receive);\n        emit({\n          kind: \"message\",\n          type,\n          payload,\n          fromUserId: from.userId,\n        });\n      },\n    });\n\n    exitRoom = result.exitRoom;\n    sendToServer = result.sendToServer;\n    return;\n  }\n\n  if (msg.cmd === \"send\") {\n    if (msg.toUserId === \"server\") {\n      sendToServer?.(msg.type, msg.payload);\n    } else if (msg.toUserId) {\n      const sendFn = peerSend.get(`${msg.host}/${msg.room}/${msg.toUserId}`);\n      if (sendFn) sendFn(msg.type, msg.payload);\n    }\n    return;\n  }\n\n  if (msg.cmd === \"exit\") {\n    exitRoom?.();\n    self.close();\n    return;\n  }\n});\n"
  ],
  "mappings": "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",
  "debugId": "D6EB547C717A39F464756E2164756E21",
  "names": []
}